CREATE DATABASE atguigudb1; 
USE atguigudb1; 
#1.创建学生表和课程表 
CREATE TABLE `student_info` (
 `id` INT(11) NOT NULL AUTO_INCREMENT, 
 `student_id` INT NOT NULL , 
 `name` VARCHAR(20) DEFAULT NULL, 
 `course_id` INT NOT NULL , 
 `class_id` INT(11) DEFAULT NULL, 
 `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, 
 PRIMARY KEY (`id`) 
 ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 
 CREATE TABLE `course` ( `id` INT(11) NOT NULL AUTO_INCREMENT, 
 `course_id` INT NOT NULL , 
 `course_name` VARCHAR(40) DEFAULT NULL, 
 PRIMARY KEY (`id`) 
 ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
 
 #创建随机产生的字符串函数
 
DELIMITER // 
CREATE FUNCTION rand_string(n INT) 
         RETURNS VARCHAR(255) #该函数会返回一个字符串 
BEGIN
    DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'; 
     DECLARE return_str VARCHAR(255) DEFAULT '';
     DECLARE i INT DEFAULT 0; 
     WHILE i < n DO 
    SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1)); 
     SET i = i + 1;
    END WHILE; 
   RETURN return_str; 
END // 
DELIMITER ;

SELECT @@log_bin_trust_function_creators variable

SET GLOBAL log_bin_trust_function_creators = 1

#创建随机产生数的函数
DELIMITER // 
CREATE FUNCTION rand_num (from_num INT ,to_num INT) 
RETURNS INT(11) 
BEGIN 
DECLARE i INT DEFAULT 0; 
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ; 
RETURN i; 
END // 
DELIMITER ;

# 存储过程1：创建插入课程表存储过程 
DELIMITER // 
CREATE PROCEDURE insert_course( max_num INT ) 
BEGIN 
DECLARE i INT DEFAULT 0; 
SET autocommit = 0; #设置手动提交事务 
REPEAT #循环 
SET i = i + 1; #赋值 
INSERT INTO course (course_id, course_name ) 
VALUES (rand_num(10000,10100),rand_string(6)); 
UNTIL i = max_num
END REPEAT; 
COMMIT; #提交事务 
END // 
DELIMITER ;

# 存储过程2：创建插入学生信息表存储过程 
DELIMITER // 
CREATE PROCEDURE insert_stu( max_num INT ) 
BEGIN 
DECLARE i INT DEFAULT 0; 
SET autocommit = 0; #设置手动提交事务 
REPEAT #循环 
SET i = i + 1; #赋值 
INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) 
VALUES (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6)); 
UNTIL i = max_num 
END REPEAT; 
COMMIT; #提交事务 
END // 
DELIMITER ;

CALL insert_course(100); 
CALL insert_stu(1000000);

#哪些情况下适合创建索引
#①字段的数值有唯一性限制
#②频繁作为where查询语句的条件
#查询当前student_info表中的索引
SHOW INDEX FROM student_info
#student_id上没有索引时
SELECT course_id,class_id,NAME,create_time,student_id
FROM student_info
WHERE student_id = 123110 #380ms

ALTER TABLE student_info
ADD INDEX idx_sid(student_id)

#student_id上有索引时
SELECT course_id,class_id,NAME,create_time,student_id
FROM student_info
WHERE student_id = 123110 #7ms

#③经常group by 和 order by 的列
SELECT student_id,COUNT(*) AS num
FROM student_info
GROUP BY student_id LIMIT 100; #3ms

#删除索引
DROP INDEX idx_sid ON student_info

SELECT student_id,COUNT(*) AS num
FROM student_info
GROUP BY student_id LIMIT 100; #811ms

#当group by 和 order by 一起使用时
#添加索引
ALTER TABLE student_info
ADD INDEX idx_sid(student_id)

ALTER TABLE student_info
ADD INDEX idx_cre_time(create_time)

ALTER TABLE student_info
ADD INDEX idx_sid_cre_time(student_id,create_time DESC)

SELECT student_id,COUNT(*) AS num FROM student_info
GROUP BY student_id
ORDER BY create_time DESC
LIMIT 100;

#update、delete中的where条件列

#distinct字段需要创建索引

#多表join连接操作时，创建索引需要注意的事项

#首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

#其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

#最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

#